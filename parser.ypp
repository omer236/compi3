%{
	#include "Expression.h"
	#include "MainProcess.h"
	#include "hw3_output.hpp"
	#include <iostream>
	void yyerror(const char* );
	int yylex();
	using namespace output;
	void handleAuto(Expression* id, Expression* exp);
	#define YYSTYPE Expression*
%}

%locations

%nonassoc VOID INT BYTE B BOOL AUTO TRUE FALSE RETURN WHILE BREAK CONTINUE SC ID NUM STRING RBRACE LBRACE IF

%right ASSIGN
%left OR
%left AND
%left EQUAL
%left RELOP
%left PLUSMINUS
%left MULTDIV
%right NOT
%left RPAREN LPAREN COMMA
%nonassoc ELSE

%%

Program: {createGlobalScope();} Funcs {closeScope();}

Funcs: /*Epsilon*/ {checkIfMainExists();}
	   | FuncDecl Funcs {}

FuncDecl: RetType ID {checkIfFuncAlreadyInSymbolTable($2);} LPAREN Formals {addFunctionEntryToSymbolTable($1,$2,$5);}
			RPAREN {openScope(); addArgumentsToSymbolTable($5);} LBRACE
			Statements RBRACE {closeScope();}

RetType: Type {$$ = $1;}
		| VOID {$$ = new Expression("","VOID");}

Formals:  /*Epsilon*/ { $$ = nullptr; }
		| FormalsList {$$=$1;}

FormalsList: FormalDecl {$$ = new ExpressionFunction($1->name,$1->type);}
			| FormalDecl COMMA FormalsList {addArgInDeclaration($3, $1); $$=$3;}

FormalDecl: Type ID {$$ = new Expression($2->name, $1->type);}


Statements: Statement {}
			| Statements Statement  {}

Statement: LBRACE {bool flag = isWhile(); openScope(flag);} Statements RBRACE {closeScope();}
			| Type ID SC {handleDeclaration($2); addVariableToSymbolTable($1, $2);}
			| Type ID ASSIGN Exp SC {handleDeclarationAndInitiation($1, $2, $4); addVariableToSymbolTable($1, $2);}
			| ID ASSIGN Exp SC {handleAssign($1, $3);}
			| AUTO ID ASSIGN Exp SC {handleAuto($2, $4); handleDeclarationAndInitiationAuto($4, $2, $4);addVariableToSymbolTable($4, $2);}
			| Call SC {}
			| RETURN SC {handleReturnVoid();}
			| RETURN Exp SC {handleExpReturn($2);}
			| IF LPAREN M1 Exp M2 RPAREN Statement M3 %prec IF {}
			| IF LPAREN M1 Exp M2 RPAREN Statement M3 ELSE {openScope();} Statement {closeScope();}
			| WHILE {openScope(1);} LPAREN Exp {logicalExpression($4);} RPAREN Statement {closeScope();}
			| BREAK SC {checkBreakOrContinue("BREAK");}
			| CONTINUE SC {checkBreakOrContinue("CONTINUE");}

M1: /*Epsilon*/ {bool flag = isWhile(); openScope(flag);}

M2: /*Epsilon*/ {logicalExpression($0);}

M3: /*Epsilon*/ {closeScope();}

Call: ID LPAREN ExpList RPAREN {handleCall($1, $3); $$ = $1;}
			| ID LPAREN RPAREN {handleCall($1); $$ = $1;}

ExpList: Exp {$$ = new ExpressionFunction($1);}
			| Exp COMMA ExpList {addArgToFunction($3, $1); $$=$3;}

Type: INT {$$ = new Expression("", "INT");};
Type: BYTE {$$ = new Expression("", "BYTE");};
Type: BOOL {$$ = new Expression("", "BOOL"); };
Type: error {}

Exp: LPAREN Exp RPAREN {$$ = $2;};
Exp: Exp PLUSMINUS Exp {$$ = handleBinop($1, $3);};
Exp: Exp MULTDIV Exp {$$ = handleBinop($1, $3);};
Exp: ID {checkID($1); $$ = $1;};
Exp:  Call {$$ = $1;};
Exp: NUM {$$ = $1;};
Exp: NUM B {$$ = handleByte($1);};
Exp: STRING {$$ = $1;};
Exp: TRUE {$$ = $1;};
Exp: FALSE {$$ = $1;};
Exp: NOT Exp { $$ = logicalExpression($2);};
Exp: Exp AND Exp {$$ = logicalExpression($1,$3);};
Exp: Exp OR Exp {$$ = logicalExpression($1,$3);};
Exp: Exp RELOP Exp {$$ = handleRelop($1,$3);};
Exp: Exp EQUAL Exp {$$ = handleRelop($1,$3);};
Exp: LPAREN Type RPAREN Exp {$$ = handleCast($2->type,$4);};

%%

void yyerror(const char*) {
	errorSyn(yylloc.first_line);
	exit(1);
}

int main() {
	return yyparse();
}

void handleAuto(Expression* id, Expression* exp){
    if(exp->type=="VOID" || exp->type=="STRING"){
        errorMismatch(yylineno);
        exit(0);
        }
}