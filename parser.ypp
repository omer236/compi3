%{
	#include "Expression.h"
	#include "System.h"
	#include "hw3_output.hpp"
	#include <iostream>
	void yyerror(const char* );
	int yylex();
	using namespace output;
	#define YYSTYPE Expression*
%}

%locations

%nonassoc VOID INT BYTE B BOOL AUTO TRUE FALSE RETURN WHILE BREAK CONTINUE SC ID NUM STRING RBRACE LBRACE IF

%right ASSIGN
%left OR
%left AND
%left EQUAL
%left RELOP
%left PLUSMINUS
%left MULTDIV
%right NOT
%left RPAREN LPAREN COMMA
%nonassoc ELSE

%%

Program: {openGlobalScope();} Funcs {closeScope();}

Funcs: /*Epsilon*/ {checkIfMain();}
	   | FuncDecl Funcs {}

FuncDecl: RetType ID {checkFuncInSymbolTable($2);} LPAREN Formals {insertFuncToSymbolTable($1,$2,$5);} 
			RPAREN {openScope(); insertArgsToSymbolTable($5);} LBRACE 
			Statements RBRACE {closeScope();}

RetType: Type {$$ = $1; }
		| VOID {$$ = new Expression("","VOID");}

Formals:  /*Epsilon*/ { $$ = nullptr; }
		| FormalsList {$$=$1;} 

FormalsList: FormalsDecl {$$ = new ExpressionFunction($1->name,$1->type,$1->is_const);}
			| FormalsDecl COMMA FormalsList {addArgInDeclaration($3, $1); $$=$3;}

FormalsDecl: TypeAnnotation Type ID {$$ = new Expression($3->name, $2->type, $1->is_const, 0);}


Statements: Statement {}
			| Statements Statement  {}

Statement: LBRACE {bool flag = checkIfInWhile(); openScope(flag);} Statements RBRACE {closeScope();}
			| TypeAnnotation Type ID SC {handleDec($1, $2, $3); insertVarToSymbolTable($1, $2, $3);}
			| TypeAnnotation Type ID ASSIGN Exp SC {handleDecAndInit($1, $2, $3, $5); insertVarToSymbolTable($1, $2, $3);}
			| ID ASSIGN Exp SC {handleAssign($1, $3);}
			| Call SC {}
			| RETURN SC {handleReturn();}
			| RETURN Exp SC {handleExpReturn($2);}
			| IF LPAREN M1 Exp M2 RPAREN Statement M3 %prec IF {}
			| IF LPAREN M1 Exp M2 RPAREN Statement M3 ELSE {openScope();} Statement {closeScope();}
			| WHILE {openScope(1);} LPAREN Exp {checkTypeBool($4);} RPAREN Statement {closeScope();}
			| BREAK SC {handleBreakOrContinue("BREAK");}
			| CONTINUE SC {handleBreakOrContinue("CONTINUE");}

M1: /*Epsilon*/ {bool flag = checkIfInWhile(); openScope(flag);}

M2: /*Epsilon*/ {checkTypeBool($0);}

M3: /*Epsilon*/ {closeScope();}

Call: ID LPAREN ExpList RPAREN {handleCall($1, $3); $$ = $1;}
			| ID LPAREN RPAREN {handleCall($1); $$ = $1;}

/* Create ExpressionFunction without name and type, contains only args name & types */
ExpList: Exp {$$ = new ExpressionFunction($1);}
			| Exp COMMA ExpList {addArgInCall($3, $1); $$=$3;}

Type: INT {$$ = new Expression("", "INT");}
		| BYTE {$$ = new Expression("", "BYTE");}
		| BOOL {$$ = new Expression("", "BOOL"); }
		| error {} /*ASAF ADDED THIS*/

TypeAnnotation:  /*Epsilon*/ {$$ = new Expression();}
				| AUTO {$$ = new Expression(true);}

Exp: LPAREN Exp RPAREN {$$ = $2;}
	| Exp PLUSMINUS Exp {$$ = handleBinop($1, $3, "-");}
	| Exp MULTDIV Exp {$$ = handleBinop($1, $3, "*");}
	| ID {handleID($1); $$ = $1;}
	| Call {$$ = $1;}
	| NUM {$$ = $1;}
	| NUM B {$$ = handleByte($1);}
	| STRING {$$ = $1;}
	| TRUE {$$ = $1;}
	| FALSE {$$ = $1;}
	| NOT Exp { $$ = handleLogical($2);}
	| Exp AND Exp {$$ = handleLogical($1,$3);}
	| Exp OR Exp {$$ = handleLogical($1,$3);}
	| Exp RELOP Exp {$$ = handleRelop($1,$3);}
	| Exp EQUAL Exp {$$ = handleRelop($1,$3);}
	| LPAREN Type RPAREN Exp {$$ = handleCast($2->type,$4);}

%%

void yyerror(const char*) {
	errorSyn(yylloc.first_line);
	exit(1);
}

int main() {
	return yyparse();
}